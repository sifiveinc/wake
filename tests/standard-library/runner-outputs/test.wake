# Test cases for runner functionality including runner output, runner errors, and runner status

# Test that a runner failure depends only on the Some/None of the error, not a non-empty error message
export def testRunnerFailWithEmptyError _: Result Unit Error =
    def run job input =
        def (Runner _ virtRun) = virtualRunner
        def result = virtRun job input
        def _ = unsafe_reportJobRunnerError job "Intentional runner error for testing"

        # Report a runner error after the job completes
        result
        | setRunnerOutputRunnerError (Some "".makeError)

    def testRunner = makeRunner "test-runner-fail-empty-error" run

    def job =
        makeExecPlan ("<test>", "runner-fail-empty-error", Nil) Nil
        | runJobWith testRunner

    def check =
        require False = job.isJobOk
        else failWithError "Expected isJobOk to return False for job with runner error"

        require Exited 0 = job.getJobStatus
        else failWithError "Expected job status to be 0, got {format job.getJobStatus}"

        # Runner status should be Some even though the error message is empty
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require Some "" = runnerStatus
        else failWithError "Expected empty but present runner status message, got: {format runnerStatus}"

        require Pass errorMsg = job.unsafe_getJobRunnerError

        require True = errorMsg ==* "Intentional runner error for testing"
        else failWithError "Unexpected runner error message: {errorMsg}"

        Pass Unit

    addErrorContext "runner-fail-empty-error" check

# Test that a runner preserves job failure status when both job and runner fail
export def testRunnerFailWithJobFailure _: Result Unit Error =
    def run job input =
        # Run a command that will fail with exit code 42
        def failingInput =
            input
            | editRunnerInputCommand (\_ ("sh", "-c", "exit 42", Nil))

        def (Runner _ baseRun) = localRunner
        def result = baseRun job failingInput

        # Report a runner error after the job completes
        result
        | setRunnerOutputRunnerError (Some "Intentional runner error with job failure".makeError)

    def testRunner = makeRunner "test-runner-fail-with-job-failure" run

    def job =
        makeExecPlan ("<test>", "runner-fail-with-job-failure", Nil) Nil
        | runJobWith testRunner

    def check =
        require False = job.isJobOk
        else failWithError "Expected isJobOk to return False for failing job"

        require Exited 42 = job.getJobStatus
        else failWithError "Expected job status 42, got {format job.getJobStatus}"

        # Runner status should be the given message since there was a runner error
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require Some errorStatus = runnerStatus
        else failWithError "Expected Some runner status, got None"

        require True = errorStatus ==* "Intentional runner error with job failure"
        else
            failWithError
            "Expected runner status to be 'Intentional runner error with job failure', got '{errorStatus}'"

        # Runner error should not duplicate the status message
        require Pass errorMsg = job.unsafe_getJobRunnerError

        require True = errorMsg ==* ""
        else failWithError "Unexpected runner error message: {errorMsg}"

        Pass Unit

    addErrorContext "runner-fail-with-job-failure" check

# Test that a runner can finish a job but mark it as failed
export def testRunnerFailFinish _: Result Unit Error =
    def run job input =
        def (Runner _ virtRun) = virtualRunner
        def result = virtRun job input

        # Force a failure outside of the actual job
        result
        | setRunnerOutputRunnerError (Some "Mark job as failure".makeError)

    def testRunner = makeRunner "test-runner-fail-finish" run

    def job =
        makeExecPlan ("<test>", "runner-fail-finish", Nil) Nil
        | runJobWith testRunner

    def check =
        # Job should be marked as failed
        require False = job.isJobOk
        else failWithError "Expected isJobOk to return False for failing job"

        require Exited 0 = job.getJobStatus
        else failWithError "Expected job status to be 0, got {format job.getJobStatus}"

        # Runner status should be the given message since a runner error is independent from job success
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require Some errorStatus = runnerStatus
        else failWithError "Expected Some runner status, got None"

        require True = errorStatus ==* "Mark job as failure"
        else failWithError "Expected runner status to be 'Mark job as failure', got '{errorStatus}'"

        Pass Unit

    addErrorContext "runner-fail-finish" check

# Test that isJobOk returns true when there's no runner error
export def testRunnerOkSuccess _: Result Unit Error =
    def job =
        makeExecPlan ("echo", "success", Nil) Nil
        | runJobWith localRunner

    def check =
        # Job should succeed
        require True = job.isJobOk
        else failWithError "Expected isJobOk to return True for successful job"

        # Runner status should be None (success)
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require None = runnerStatus
        else failWithError "Expected None runner status for successful job, got '{format runnerStatus}'"

        Pass Unit

    addErrorContext "runner-ok-success" check

# Test that a wrapper runner correctly propagates runner status
export def testWrapperRunnerStatus _: Result Unit Error =
    # Create an inner runner that sets a runner error and status
    def innerRun job input =
        def (Runner _ virtRun) = virtualRunner
        def result = virtRun job input
        def _ = unsafe_reportJobRunnerError job "Inner runner printed error\n"

        # Set a runner error
        result
        | setRunnerOutputRunnerError (Some "Inner runner error".makeError)

    def innerRunner = makeRunner "inner-runner" innerRun

    # Create a wrapper runner that adds a prefix to runner errors
    def wrapperRun job input =
        # First run the job with the inner runner
        def innerInput = input
        def (Runner _ innerDoIt) = innerRunner
        def result = innerDoIt job innerInput

        match (unsafe_getJobRunnerError job)
            Pass errorMsg if errorMsg !=* "" ->
                # Add a prefix to the error message
                def newErrorMsg = "WRAPPER: {errorMsg}"
                def _ = unsafe_reportJobRunnerError job newErrorMsg

                # Keep the same runner status (should be "Inner runner error" from inner runner)
                result
            _ -> result

    def wrapperRunner = makeRunner "wrapper-runner" wrapperRun

    # Create a job that uses the wrapper runner (which uses the inner runner)
    def job =
        makeExecPlan ("echo", "test", Nil) Nil
        | runJobWith wrapperRunner

    def check =
        # Wait for job to complete
        require Fail _ = job.getJobOutputs
        else failWithError "Expected job 'echo test' to fail due to inner runner error"

        # Verify the runner status is preserved from the inner runner
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require Some errorStatus = runnerStatus
        else failWithError "Expected Some runner status, got None"

        require True = errorStatus ==* "Inner runner error"
        else failWithError "Expected runner status to be 'Inner runner error', got '{errorStatus}'"

        # Verify the error message has been prefixed by the wrapper
        require Pass errorMsg = job.unsafe_getJobRunnerError

        require True =
            errorMsg ==* "Inner runner printed error\nWRAPPER: Inner runner printed error\n"
        else failWithError "Unexpected runner error message: {errorMsg}"

        Pass Unit

    addErrorContext "wrapper-runner" check

# Test that writes to different file descriptors to verify runner output/error capture
# and proper ordering with runner-reported messages
export def testFdOutputs _: Result Unit Error =
    # Create a temporary script that writes to fd 3 and fd 4
    require Pass scriptPath =
        writeTempFile
        "fd_test.sh"
        """
        #!/bin/bash
        # Write to stdout (fd 1)
        echo "This is standard output"
        # Write to stderr (fd 2)
        echo "This is standard error" >&2
        # Write to fd 3 (runner output)
        echo "This is runner output" >&3
        # Write to fd 4 (runner error)
        echo "This is runner error" >&4
        # Exit successfully
        exit 0
        """

    require Pass _ =
        makeExecPlan ("chmod", "+x", scriptPath.getPathName, Nil) (scriptPath, Nil)
        | runJobWith localRunner
        | getJobOutputs
        | addErrorContext "fd-outputs"

    # Create a custom runner that reports messages before and after script execution
    def run job input =
        # Report runner messages before execution
        def _ = unsafe_reportJobRunnerOutput job "RUNNER: Before execution\n"
        def _ = unsafe_reportJobRunnerError job "RUNNER: Before execution error\n"
        def (Runner _ virtRun) = localRunner
        def result = virtRun job input

        # Wait for job to complete
        require None = result.getRunnerOutputRunnerError
        else result

        # Report runner messages after execution
        def _ = unsafe_reportJobRunnerOutput job "RUNNER: After execution\n"
        def _ = unsafe_reportJobRunnerError job "RUNNER: After execution error\n"

        result

    def testRunner = makeRunner "test-runner-fd-outputs" run

    # Run with our custom runner
    def job =
        makeExecPlan (scriptPath.getPathName, Nil) (scriptPath, Nil)
        | editPlanEnvironment (setEnvironment "WAKE_ALLOW_RUNNER_STREAMS" "1")
        | runJobWith testRunner

    def check =
        # Wait for job to complete
        require Pass _ = job.getJobOutputs
        require Pass stdout = job.getJobStdout
        require Pass stderr = job.getJobStderr
        require Pass runnerOutput = job.unsafe_getJobRunnerOutput
        require Pass runnerError = job.unsafe_getJobRunnerError

        require True = stdout ==* "This is standard output\n"
        else failWithError "Unexpected stdout: '{stdout}'"

        require True = stderr ==* "This is standard error\n"
        else failWithError "Unexpected stderr: '{stderr}'"

        # Verify runner output contains messages in proper order: before, script fd3, after
        def expectedRunnerOutput =
            "RUNNER: Before execution\nThis is runner output\nRUNNER: After execution\n"

        require True = runnerOutput ==* expectedRunnerOutput
        else failWithError "Unexpected runner output: '{runnerOutput}', expected: '{expectedRunnerOutput}'"

        # Verify runner error contains messages in proper order: before, script fd4, after
        def expectedRunnerError =
            "RUNNER: Before execution error\nThis is runner error\nRUNNER: After execution error\n"

        require True = runnerError ==* expectedRunnerError
        else failWithError "Unexpected runner error: '{runnerError}', expected: '{expectedRunnerError}'"

        def _ = println "All file descriptor outputs verified successfully"

        Pass Unit

    addErrorContext "fd-outputs" check

# Test that a runner can report custom output information
export def testRunnerCustomOutput _: Result Unit Error =
    # Create a custom runner that reports output information
    def run job input =
        def (Runner _ virtRun) = virtualRunner
        def result = virtRun job input
        def _ = unsafe_reportJobRunnerOutput job "Custom runner information: test data"

        result

    def testRunner = makeRunner "test-runner-custom-output" run

    def job =
        makeExecPlan ("<test>", "runner-custom-output", Nil) Nil
        | runJobWith testRunner

    def check =
        # Wait for job to complete
        require Pass _ = job.getJobOutputs

        # Runner status should be None since there was no runner error (just a print to the error stream)
        require Pass runnerStatus = job.unsafe_getJobRunnerStatusMessage

        require None = runnerStatus
        else failWithError "Expected None runner status for successful job, got '{format runnerStatus}'"

        # Verify the runner output contains our custom message
        require Pass runnerOutput = job.unsafe_getJobRunnerOutput

        require True = runnerOutput ==* "Custom runner information: test data"
        else failWithError "Unexpected runner output: '{runnerOutput}'"

        require True = job.isJobOk
        else failWithError "Expected isJobOk to return True for job with custom runner output"

        Pass Unit

    addErrorContext "runner-custom-output" check
